function ssp = meg_ssp(MEG,lf,varargin)% NAME:    ssp.m% AUTHORS: Peter Teale, M.S.E.E. and Don Rojas, Ph.D.% PURPOSE: to produce source space projection Q(t) waveform for a single%          source location from MEG data produced on a 4DNeuroimaging%          system.% USAGE:   ssp = meg_ssp(MEG, lf)% INPUTS:  MEG = MEG struct from get4D.m%          lf  = leadfield (nchan x 3) from meg_singlesphere_lf.m or other%          'covariance', cov = covariance matrix (optional): should by%          nchan x nchan matrix;%          'lambda', regularization factor as decimal fraction (.02 for 2%)% OUTPUT:  ssp.Q     = Q(t) waveform in source space (i.e., virtual%                      electrode), in A-m (multiply by 1e9 for nA-m).%          ssp.W     = Weight vector (1 x nchan) for SSP%          ssp.time  = vector of time points for plotting (e.g., plot(time,%                      Q)) results% TO DO:   (1) add options to calculate covariance within function%          (2) release restriction to dominant orientation using svd and%              allow Q to have 3 x nsamp dimensions% SEE ALSO: TFT, MEG_SINGLESPHERE_LF% HISTORY: 06/20/08 original m-file from baSSP.m by Peter Teale.%          01/29/09 Added baseline correction, change to optional in%                   future (code from Peter).%          06/28/10 Improved speed of algorithm by pre-assigned%                   memory and dot operations on epochs instead of samples.%          10/12/11 Separated projection code from leadfield code%          11/02/11 Cleaned up baseline correction, added averaging option% some crude error checkingcind    = meg_channel_indices(MEG,'multi','MEG');nchan   = length(cind);if nchan ~= size(lf,1)    error('Leadfield length does not match number of MEG channels!');end% defaultsC           = [];ratio       = .05;basecorr    = 'true';average     = 'false';if ~isempty(varargin)    optargin = size(varargin,2);    if (mod(optargin,2) ~= 0)        error('Optional arguments must come in option/value pairs');    else        for ii=1:2:optargin            switch varargin{ii}                case 'covariance'                    C = varargin{ii+1};                case 'lambda'                    ratio = varargin{ii+1};                case 'average'                    average  = varargin{ii+1};                case 'baseline'                    basecorr = varargin{ii+1};                otherwise                    error('Invalid option!');            end        end    endendif strcmpi(basecorr,'true') || strcmpi(basecorr,'yes')    basecorr = 1;else    basecorr = 0;endif strcmpi(average,'true') || strcmpi(average,'yes')    average = 1;else    average = 0;end% compute weight vector, use covariance matrix if present. The covariance% matrix, if used, suppresses correlated activity (i.e., weights are% computed as in beamformer)if size(lf,2) > 1    if ~isempty(C)        lambda  = ratio * trace(C)/size(C,1);        invC    = pinv(C+lambda*eye(size(C)));        [u,s,v] = svd(real(pinv(lf'*invC*lf)));    else        [u,s,v] = svd(real(pinv(lf'*lf)));    end    lf      = lf * u(:,1); % restrict to dominant orientation    if ~isempty(C)        filt = pinv(lf'*invC*lf)*lf'*invC; % see van Veen '97 eq(23)    else        filt    = pinv(lf);    endelse    filt = pinv(lf);end% compute Q(t)=dot(meg,W) using weights (W) and measured fieldsswitch MEG.type    case 'epochs'        nepochs = size(MEG.data,1);        nsamp   = size(MEG.data,3);        ssp.Q   = zeros(nepochs,nsamp);        for i=1:nepochs            ssp.Q(i,:) = filt*squeeze(MEG.data(i,cind,:));        end    otherwise        nsamp   = size(MEG.data,2);        nepochs = 1;        ssp.Q   = zeros(1,nsamp);        ssp.Q   = filt*MEG.data(cind,:);end% average if requestedif average && strcmp(MEG.type,'epochs')    ssp.Q    = mean(ssp.Q);	nepochs   = 1;end% baseline correctionif basecorr    stop = get_time_index(MEG,0);    for ii=1:nepochs        baseline = mean(ssp.Q(ii,1:stop));        ssp.Q(ii,:) = ssp.Q(ii,:)-baseline;    endend% fill out ssp structuressp.time  = MEG.time;ssp.W     = filt;ssp.epdur = MEG.epdur;