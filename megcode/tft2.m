function tf = tft(indat,freq,varargin)% Function: tft.m% Author:   Peter Teale, M.S.E.E., modified by Don Rojas, Ph.D.% Purpose:  To compute Time-Frequency info from MEG/EEG source space%           projected *Qt.mat files (see SSP.m) using wavelets% Inputs:   indat - struct from get4D.m, should be epoch type, or ssp%                   struct from ssp.m, should also be epochs. Can either be string%                   refererence to file name or can be variable name from workspace.%           freq  - [low high] vector of frequency cutoffs% Optional: 'bc', n: n = baseline correction method. Valid options are:%                  1 : subtraction%                  2 : percent change (default)%                  3 : dB change%                  4 : z-score change     %           'waven', w - wave number for tft (default = 6), OR%           'waven', [w1 w2], wave number low and high for scaling with%                    frequencies, similar to EEGLAB, OR%           'waven', [w1,w2,...,wN], where wN is same size as low:high, so%                    with this variation you can specify the ACTUAL wave numbers%                    you want for each frequency if you don't like the ones chosen%                    by the program in option 2.%           'bcdef', [first,last], baseline points in ms (default = entire%                    prestim region%           'raw',   0 (default) = no raw complex data in tf, 1 returns%                    complex data, can be useful for compass plots etc.%           'chan'  - channel to compute time-frequency transform e.g.,%                    'A142', must be supplied for MEG type input% Outputs:  tf structure containing fields:%           mplf    = mean phase locking factor (a.k.a., ITC)%           tpower  = total power (evoked + induced)%           epower  = evoked power, or phase-locked power%           ipower  = induced power, or non-phase-locked power%           ntpower = baseline corrected tpower%           nepower = baseline corrected epower%           nipower = baseline corrected ipower%           morl    = Morlet wavelet waveform for highest frequency%           mask    = array of 0 and 1 for each time-frequency point that%                     allows plotting of edge effect areas.%           waven   = wavenumber vector used% Usage:    tf = tft(MEG,[5 80],121,'waven',7); will produce a time frequency%           transform on data structure MEG, channel 121, from 5 to 50 Hz, %           wave #7%           tf = tft(MEG,[5 100],'waven',[3 12],'bcdef',[-1000 -800]); will produce a time%           frequency transform on a file from 5 to 100 Hz, with wave%           number scaled linearly from 3 to 12 as frequency increases and%           a baseline definition of -1000 to -800 ms.% Notes:    1) Only Morlet wavelet is supported% To do:    1) save raw units and norm units in tf struct%           2) save morl field as array for each freq centered in time%              vector at time 0 (nice for visualization of scales)% History:  Rev 1, Sept. 2008, based on QTF.m%           Rev 2, March 2010 to reflect Don's toolbox's inputs and calc%           TFT on arbitrary channel level input%           Rev 3, July 2010 to add edge mask output%           07/21/10 - fixed bug with mask output: number of samples was%                      incorrect for invalid frequencies%           07/26/11 - fixed bug with channel indexing and require channel%                      labels instead of numbers%           9/15/11  - allow wave number to scale with frequency, like%                      EEGLAB%           9/15/11  - integrated qft.m and tft.m from old megcode version.%                      now either can received workspace or file input%           9/16/11  - can return complex data now if 'raw' option set%           10/14/11 - minor modification to update channel%                      specification if doing channel tf.% keep track of calculation timetic;% figure out input source to functionif isa(indat,'char')    % see if file exists    if ~exist(indat,'file')        error('File %s does not exist!',indat);    else        indat = load(indat,'-mat');    endend% some defaultswaven       = 6; % default wave number (n cycles in wavelet), decent for gamma-band studiesbc          = 2; % default baseline method, percent changeisMEG       = 1; % default is MEG input for channel tfraw         = 0; % no complex data are returned% determine type of structureflds = fieldnames(indat);if length(flds) > 1    if isfield(indat,'Q')        ssp   = indat;        isMEG = 0;    elseif isfield(indat,'cori')        MEG  = indat;    else        error('Unable to determine type of structure input from %s',indat);    endelse % see if field is in one level because of load from file    if isfield(indat.(flds{1}),'Q') % probably ssp type        ssp   = indat.(flds{1});        isMEG = 0;    elseif isfield(indat.(flds{1}),'cori') % probably MEG type        MEG  = indat.(flds{1});    endendclear('indat');% change defaults if requestedif ~isempty(varargin)    optargin = size(varargin,2);    if (mod(optargin,2) ~= 0)        error('Optional arguments must come in option/value pairs');    else        for i=1:2:optargin            switch varargin{i}                case 'waven'                    waven    = varargin{i+1};                 case 'bc'                    bc       = varargin{i+1};                case 'bdef'                    first    = get_time_index(MEG,varargin{i+1}(1));                    last     = get_time_index(MEG,varargin{i+1}(2));                case 'raw'                    if varargin{i+1} == 1                        raw  = 1;                    end                case 'chan'                    chan     = varargin{i+1};                otherwise                    error('Option ''%s'' is not a valid option! See help.',varargin{i});            end        end    endend% get the channel or Q data and other params as input requiresif isMEG    if ~strcmp(MEG.type,'epochs')        error('MEG struct type must be ''epochs''');    end    cind=meg_channel_indices(MEG,'labels',chan);    if isempty(cind)        error('Requested channel is missing from array');    else        data    = squeeze(MEG.data(:,cind,:));        speriod = 1/MEG.sr;        time    = MEG.time;        epochs  = size(MEG.data,1);        points  = size(MEG.data,3);    end    fprintf('\nCalculating time-frequency transform for channel: %s...',char(MEG.chn(cind).label));else    data    = ssp.Q;    epochs  = size(data,1);    points  = size(data,2);    time    = ssp.time;    epdur   = ssp.epdur;    prestim = ssp.time(1);    speriod = ssp.epdur/points;    fprintf('\nCalculating time-frequency transform for ssp...');endfs          = 1/speriod;first       = 1;tmp.time    = time;last        = get_time_index(tmp,0); clear('tmp');% get some parameters for the transformlowF    = freq(1);hiF     = freq(2);% scale wave number with frequency if requestedif length(waven) > 1    if length(waven) == 2        waven = linspace(waven(1),waven(2),length(lowF:hiF))';    elseif length(waven) == length(lowF:hiF)        % no scaling required since specific wave numbers are entered for        % each frequency    else        error('Wave number input incorrectly formatted!');    endelse    waven = repmat(waven,length(lowF:hiF),1);end% preallocate space for tftCmeg=zeros(hiF-lowF+1,epochs,points*2); % extra space for zero padding endsPmeg=zeros(hiF-lowF+1,epochs,points);   % will hold magnitude normalized valuesTmeg=Pmeg;                              % same as Cmeg, but without padding% Wavelet transform for each frequency% Note: in Roach and Mathalon (2008), c = df/sigf for this function. m% = waven and can be set in the call to function.for df = lowF:1:hiF % look at different frequencies from lowF to hiF, 1 Hz increments    dfi     = df - lowF + 1; % index for frequency    s       = 2*pi*df/fs;    sigf    = df/waven(dfi); % frequency variance (see Roach paper p. 920)    sigt    = 1/(2*pi*sigf); % time variance    lw      = round((waven(dfi)/df)/speriod); % length of wavelet in sample points    Aw      = 2/(fs*sigt*sqrt(2*pi)); % normalized amplitude for the wavelet     w       = 1:lw; % make sure w does not have trailing zeros    % old code - works, but not vectorized    %for t = 1:lw    %    w(t) = Aw*exp(-(((t-(lw/2))/fs)^2)/(2*sigt^2))*exp(s*t*j);% wavelet vector    %end    t  = 1:lw;    w  = Aw*exp(-(((t-(lw/2))/fs).^2)/(2*sigt^2)).*exp(s*t*1i);    %new beginning and endpoints after convolution    bp = round(lw/2);ep=points-1+round(lw/2);    for eps = 1:epochs        Cmeg(dfi,eps,1:points+lw-1) = conv(w,(data(eps,:)));        Pmeg(dfi,eps,1:points)      = Cmeg(dfi,eps,bp:ep)./abs(Cmeg(dfi,eps,bp:ep));        Tmeg(dfi,eps,1:points)      = Cmeg(dfi,eps,bp:ep);    end    tf.mplf(dfi,:) = abs(mean(Pmeg(dfi,:,:)));    tf.morl{df}  = w;endtf.tpower = squeeze(mean(abs(Tmeg),2)); % this would be evoked plus inducedtf.epower = squeeze(abs(mean(Tmeg,2))); % this would be the evoked onlytf.ipower = tf.tpower-tf.epower;        % this is the induced power% calculate mask of 1/2 wavelet length for edge effectstf.mask = ones(length(lowF:hiF),points);for df = lowF:hiF    dfi      = df - lowF + 1;    wlen     = round((waven(dfi)/df)/speriod);    slen     = round(wlen/2); % 1/2 wavelet length in samples    if slen > points        tf.mask(dfi,1:points) = 0;    else        tf.mask(dfi,1:slen)            = 0;        tf.mask(dfi,end-(slen-1):end)  = 0;    endend% baseline corrected relative values - reference Roach and% Mathalon (2008) paper - method numbers correspond to that reference (p. 918):baseTP = repmat(mean(tf.tpower(:,first:last),2),1,points);baseEP = repmat(mean(tf.epower(:,first:last),2),1,points);baseIP = repmat(mean(tf.ipower(:,first:last),2),1,points);sdTP = repmat(std(tf.tpower(:,first:last),0,2),1,points);sdEP = repmat(std(tf.epower(:,first:last),0,2),1,points);sdIP = repmat(std(tf.ipower(:,first:last),0,2),1,points);switch bc    case 1 % subtract baseline only        tf.ntpower = tf.tpower-baseTP; %normalized total power        tf.nepower = tf.epower-baseEP; %normalized evoked        tf.nipower = tf.ipower-baseIP; %normalized induced        norm_unit = 'amplitude';    case 2 % express as percent change        tf.ntpower = (tf.tpower-baseTP)./baseTP; %normalized total power        tf.nepower = (tf.epower-baseEP)./baseEP; %normalized evoked        tf.nipower = (tf.ipower-baseIP)./baseIP; %normalized induced        norm_unit = 'percent';    case 3 % express in dB change        tf.ntpower = (log10(tf.tpower./baseTP))*20; %normalized total power        tf.nepower = (log10(tf.epower./baseEP))*20; %normalized evoked        tf.nipower = (log10(tf.ipower./baseIP))*20; %normalized induced        norm_unit = 'dB';    case 4 % express in units of Z-score change        tf.ntpower = (tf.tpower-baseTP)./sdTP; %normalized total power        tf.nepower = (tf.epower-baseEP)./sdEP; %normalized evoked        tf.nipower = (tf.ipower-baseIP)./sdIP; %normalized induced        norm_unit = 'z-score';end% fill out tf structuretf.time  = time;tf.freq  = lowF:hiF;tf.units = norm_unit;tf.waven = waven;if raw    tf.raw = Tmeg;end% report time taken in functiont=toc;fprintf('Time: %.2f seconds\n',t);end