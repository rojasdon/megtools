function tf = qtf(filename,low,high,varargin)% Function: qtf.m% Author:   Peter Teale, M.S.E.E., modified by Don Rojas, Ph.D.% Purpose:  To compute Time-Frequency info from MEG/EEG source space%           projected *Qt.mat files (see ssp.m) using wavelets% Inputs:   filename, of file containing ssp struct having fields:%               Qt      - nepoch x nsamples array of Q, in n-Am%               epdur   - epoch duration in seconds%               time    - time vector%           low  = low end of tf transform in Hz%           high = high end of tf transform in Hz% Optional Inputs, in comma-separated pairs:%           'waven', n: n = wavenumber%           'bc', n: n = baseline correction method. Valid options are:%                  1 : subtraction%                  2 : percent change%                  3 : dB change%                  4 : z-score change          % Outputs:  tf structure containing fields:%           mplf    = mean phase locking factor (a.k.a., ITC)%           tpower  = total power (evoked + induced)%           epower  = evoked power, or phase-locked power%           ipower  = induced power, or non-phase-locked power%           ntpower = baseline corrected tpower%           nepower = baseline corrected epower%           nipower = baseline corrected ipower%           morl    = Morlet wavelet waveform for highest frequency%           mask    = array of 0 and 1 for each time-frequency point that%                     allows plotting of edge effect areas.% Usage:    tf = qtf('filename',5,50,'waven',7,'bc',); will produce a time frequency%           transform on a file from 5 to 50 Hz% Notes:    1) Baseline correction is currently inflexible - the entire%           pre-stim baseline is taken - this should be modified in a%           future version%           2) Only Morlet wavelet is supported%           3) contourf(tf.time,tf.freq,tf.nepower,20,'linestyle','none')%           will plot nice result. If you then type hold on, then,%           contourf(tf.time,tf.freq,tf.mask,[1 1], 'linecolor','white')%           you will get an overplot of the edge mask, outside of which you%           should not report any data (see Roach and Mathalon 2008).% To do:    1) Option to use mask to actually NaN the data% See also: MEG_SSP% FIXME:    Integrate this code with tft.m to avoid having to maintain%           changes in two nearly identical functions% History:  Rev 1, Sept. 2008%           Rev 2, March 2010 to reflect Don's toolbox's inputs%           Rev 3, July 2010 to add edge mask output%           Rev 4, Allow several different baseline correction methods%           3/27/11 - fixed baseline sample calculation issue tic;bias = 0;% check inputsif exist(filename,'file')      load(filename);else    error('file not found!');endif ~isfield(ssp,'Q'); error('File is missing Qt array'); end;if ~isfield(ssp,'epdur'); error('File is missing epdur field'); end;if ~isfield(ssp,'time'); error('File is missing time field'); end;fprintf('\nComputing time-frequency transform on %s',filename);Q       = ssp.Q;Qsize   = size(Q);epochs  = Qsize(1);points  = Qsize(2);epdur   = ssp.epdur;prestim = ssp.time(1);speriod = ssp.epdur/points;lowF    = low;hiF     = high;fs      = 1 / speriod;% defaultswaven       = 6; % default wave number (n cycles in wavelet), decent for gamma-band studiesbc          = 2; % default baseline method, percent change[t s]       = min(abs(ssp.time) - 0);stop        = s - 1; % stop point in samplesstart       = 1; % start point in samples% change defaults if requestedif ~isempty(varargin)    optargin = size(varargin,2);    if (mod(optargin,2) ~= 0)        error('Optional arguments must come in option/value pairs');    else        for i=1:2:optargin            switch varargin{i}                case 'waven'                    waven    = varargin{i+1};                 case 'bc'                    bc       = varargin{i+1};                otherwise                    error('Invalid option!');            end        end    endendCmeg=zeros(hiF-lowF+1,epochs,points*2); %extra space for paddingPmeg=zeros(hiF-lowF+1,epochs,points);Tmeg=Pmeg;for df = lowF:1:hiF % look at different frequencies from lowF to hiF, 1 Hz increments    dfi     = df - lowF + 1; % index for frequency    s       = 2*pi*df/fs;    sigf    = df/waven; %wavelet number = 7    sigt    = 1/(2*pi*sigf); %time variance    lw      = round((waven/df)/speriod); %length of wavelet in sample points    Aw      = 2/(fs*sigt*sqrt(2*pi)); %normalized amplitude for the wavelet     w       = 1:lw; % make sure w does not have trailing zeros    for t = 1:lw %width of w is ~(7 times 1/df)/speriod        w(t) = Aw*exp(-(((t-(lw/2))/fs)^2)/(2*sigt^2))*exp(s*t*j);% wavelet vector    end    %new beginning and endpoints after convolution    bp = round(lw/2);ep=points-1+round(lw/2);    for eps = 1:epochs        Cmeg(dfi,eps,1:points+lw-1) = conv(w,(Q(eps,:)));        Pmeg(dfi,eps,1:points)      = Cmeg(dfi,eps,bp:ep)./abs(Cmeg(dfi,eps,bp:ep));        Tmeg(dfi,eps,1:points)      = Cmeg(dfi,eps,bp:ep);    end    tf.mplf(dfi,:) = abs(mean(Pmeg(dfi,:,:)));endtf.tpower = squeeze(mean(abs(Tmeg),2)); % this would be evoked plus inducedtf.epower = squeeze(abs(mean(Tmeg,2))); % this would be the evoked onlytf.ipower = tf.tpower-tf.epower;      % this is the induced power%start      = round((abs(prestim/1000)/epdur) * points); % zero point in samples% calculate cone of influence% for Morlet, coi = sqrt(2*scales)mask = ones(length(lowF:hiF),points);for df = lowF:hiF    dfi      = df - lowF + 1;    wlen     = (1/df * waven)/2; % 1/2 window length in seconds    slen     = round(wlen/speriod);     % in samples    mask(dfi,1:slen)            = 0;    mask(dfi,end-(slen-1):end)  = 0;end% baseline corrected relative values - reference Roach and% Mathalon (2008) paper - method numbers correspond to that reference (p. 918):baseTP = repmat(mean(tf.tpower(:,1:stop),2),1,points);baseEP = repmat(mean(tf.epower(:,1:stop),2),1,points);baseIP = repmat(mean(tf.ipower(:,1:stop),2),1,points);sdTP = repmat(std(tf.tpower(:,1:stop),0,2),1,points);sdEP = repmat(std(tf.epower(:,1:stop),0,2),1,points);sdIP = repmat(std(tf.ipower(:,1:stop),0,2),1,points);switch bc    case 1 % subtract baseline only        tf.ntpower = tf.tpower-baseTP; %normalized total power        tf.nepower = tf.epower-baseEP; %normalized evoked        tf.nipower = tf.ipower-baseIP; %normalized induced        norm_unit = 'amplitude';    case 2 % express as percent change        tf.ntpower = (tf.tpower-baseTP)./baseTP; %normalized total power        tf.nepower = (tf.epower-baseEP)./baseEP; %normalized evoked        tf.nipower = (tf.ipower-baseIP)./baseIP; %normalized induced        norm_unit = 'percent';    case 3 % express in dB change        tf.ntpower = (log10(tf.tpower./baseTP))*20; %normalized total power        tf.nepower = (log10(tf.epower./baseEP))*20; %normalized evoked        tf.nipower = (log10(tf.ipower./baseIP))*20; %normalized induced        norm_unit = 'dB';    case 4 % express in units of Z-score change        tf.ntpower = (tf.tpower-baseTP)./sdTP; %normalized total power        tf.nepower = (tf.epower-baseEP)./sdEP; %normalized evoked        tf.nipower = (tf.ipower-baseIP)./sdIP; %normalized induced        norm_unit = 'z-score';end% various useful outputtf.time     = ssp.time;tf.freq     = lowF:hiF;tf.mask     = mask;tf.morl     = w;tf.units    = norm_unit;% uncomment to get entire raw transform - can be useful for% plotting phase/magnitude polar and/or compass plots%tf.all     = Tmeg;t=toc;fprintf('\nTime: %.2f seconds\n',t);end